<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="신진수">
<meta name="dcterms.date" content="2024-03-18">
<meta name="description" content="한빛미디어 블로그에 제가 책에 쓴 에필로그가 포스팅 되었습니다.">

<title>가짜연구소 인과추론팀 Blog - 실무로 통하는 인과추론 with 파이썬 #01 - 에필로그</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="가짜연구소 인과추론팀 Blog">
<meta property="og:description" content="가짜연구소 인과추론팀의 인과추론 블로그입니다.">
<meta property="og:image" content="https://CausalInferenceLab.github.io/posts/실무로 통하는 인과추론 with 파이썬/images/book_image.png">
<meta property="og:site_name" content="가짜연구소 인과추론팀 Blog">
<meta property="og:image:height" content="3647">
<meta property="og:image:width" content="3104">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../images/causal_inference_team_logo.jpg" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">가짜연구소 인과추론팀 Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">about</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://causalinferencelab.github.io/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">실무로 통하는 인과추론 with 파이썬 #01 - 에필로그</h1>
                  <div>
        <div class="description">
          <p>한빛미디어 블로그에 제가 책에 쓴 에필로그가 포스팅 되었습니다.</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">실무로 통하는 인과추론</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>신진수 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">March 18, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#에필로그-배경" id="toc-에필로그-배경" class="nav-link active" data-scroll-target="#에필로그-배경">에필로그 배경</a></li>
  <li><a href="#인과추론-적용을-위한-험난한-여정" id="toc-인과추론-적용을-위한-험난한-여정" class="nav-link" data-scroll-target="#인과추론-적용을-위한-험난한-여정">인과추론 적용을 위한 험난한 여정</a>
  <ul class="collapse">
  <li><a href="#도메인-지식-습득" id="toc-도메인-지식-습득" class="nav-link" data-scroll-target="#도메인-지식-습득">(1) 도메인 지식 습득</a></li>
  <li><a href="#신뢰-쌓기" id="toc-신뢰-쌓기" class="nav-link" data-scroll-target="#신뢰-쌓기">(2) 신뢰 쌓기</a></li>
  <li><a href="#실험-설계" id="toc-실험-설계" class="nav-link" data-scroll-target="#실험-설계">(3) 실험 설계</a></li>
  <li><a href="#실험-진행-및-분석" id="toc-실험-진행-및-분석" class="nav-link" data-scroll-target="#실험-진행-및-분석">(4) 실험 진행 및 분석</a></li>
  <li><a href="#실험을-바탕으로-의사결정-및-피드백" id="toc-실험을-바탕으로-의사결정-및-피드백" class="nav-link" data-scroll-target="#실험을-바탕으로-의사결정-및-피드백">(5) 실험을 바탕으로 의사결정 및 피드백</a></li>
  </ul></li>
  <li><a href="#reference" id="toc-reference" class="nav-link" data-scroll-target="#reference">Reference</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>이 포스트는 <a href="https://www.hanbit.co.kr/channel/category/category_view.html?cms_code=CMS8017671681">한빛미디어 블로그</a>에도 소개되어 있습니다.</p>
<div class="columns">
<div class="column" style="width:30%;">
<section id="book" class="level2">
<h2 class="anchored" data-anchor-id="book">Book</h2>
<p><a href="https://www.yes24.com/Product/Goods/125196916"><img src="https://image.yes24.com/goods/125196916/XL.png" class="img-fluid"></a></p>
</section>
</div><div class="column" style="width:5%;">

</div><div class="column" style="width:65%;">
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<ul>
<li>안녕하세요, “실무로 통하는 인과추론 with 파이썬” 역자 <a href="https://www.linkedin.com/in/jinsoo-shin-436060162/">신진수</a>입니다.</li>
<li>이 포스트는 번역서의 첫 번째 컨텐츠인 “실무에 인과추론 적용하기 위한 험난한 5단계 여정”에 대해 소개할 예정입니다.</li>
</ul>
</section>
</div>
</div>
<section id="에필로그-배경" class="level2">
<h2 class="anchored" data-anchor-id="에필로그-배경">에필로그 배경</h2>
<p>운이 좋게도 한빛미디어와 오라일리의 지원으로 책을 번역하며 제 생각을 에필로그에 담을 수 있었습니다. 첫 번역서를 작업하면서 책의 다섯 페이지에 제 생각을 담은 글을 쓸 수 있어 매우 기쁘네요. 지분으로 보면, 99%의 번역과 1%의 글쓰기라고 해야할까요😁</p>
<p>에필로그를 적은 배경은 다음과 같습니다.</p>
<ul>
<li>파편화된 책 내용을 사례(ex.프라임 카드)와 함께 실무 스토리로 재해석</li>
<li>조직의 문제 해결에 있어 도메인 지식과 협업의 중요성 강조</li>
<li>AGI 시대에 더욱 중요해질 “#인과추론”의 중요성 설명</li>
</ul>
<p>에필로그를 바탕으로 책에서 파편화된 내용을 일목요연하게 정리하고 이론과 실무의 간극을 좁히려고 했습니다. 또한, 제가 겪은 경험을 바탕으로 실무자가 초기에 직면할 수 있는 주요 고민들을 식별하고, 이 고민들을 해결하기 위한 인과추론 접근법에 대한 실질적인 조언을 제공하고자 했습니다.</p>
</section>
<section id="인과추론-적용을-위한-험난한-여정" class="level2">
<h2 class="anchored" data-anchor-id="인과추론-적용을-위한-험난한-여정">인과추론 적용을 위한 험난한 여정</h2>
<p>원인과 결과를 정확히 파악하는 것은 매우 중요하지만, 인과추론을 적용하는 과정은 종종 어려움을 동반합니다. 이 과정에서 제가 실제로 겪었던 경험을 프라임 카드 사례와 결합하여 이야기하고자 합니다. 이를 통해 인과추론을 실무에 적용하는 과정에서 발생하는 다음과 같은 단계들을 자세히 설명하겠습니다.</p>
<section id="도메인-지식-습득" class="level3">
<h3 class="anchored" data-anchor-id="도메인-지식-습득">(1) 도메인 지식 습득</h3>
<p>인과추론은 제품의 도메인과 밀접하게 연결되어 있습니다. 데이터 분석가라면 맡은 제품과 시장을 이해해야만 고객과 조직의 관점에서 문제가 무엇인지, 그리고 해당 문제의 크기는 어떠한지 정의할 수 있기 때문입니다. 프라임 카드 예시에서 여러분이 데이터 분석가 또는 과학자라면 카드의 종류와 특징 및 카드 결제 과정에 대해 이해하고 있어야 하죠.</p>
</section>
<section id="신뢰-쌓기" class="level3">
<h3 class="anchored" data-anchor-id="신뢰-쌓기">(2) 신뢰 쌓기</h3>
<p>카드 분야를 충분히 이해하고 있다면, 프라임 카드 문제 해결을 위해 기획, 개발, 마케팅 등 여러 부서와의 긴밀한 소통이 필수적입니다. 데이터 기반 의사결정은 초기에 내리기 쉽지 않습니다. 하지만, 데이터 사용이 어떻게 각자의 성과에 도움이 되는지를 데이터 분석가가 협업 구성원들에게 지속적으로 설득하고 신뢰를 쌓아간다면 충분히 데이터 기반의 의사결정을 내릴 수 있습니다. 데이터가 흐르는 조직을 구축하고자 한다면, 신뢰 형성을 위해 다음과 같은 단계들이 필요합니다.</p>
<ul>
<li>라이브 대응 및 추출 요청: 함께 일하는 동료들과 신뢰를 형성하기 위한 첫 단계</li>
<li>주기적인 분석 자동화: 반복되는 업무는 자동화할 수 있도록 대시보드/플랫폼화하는 단계</li>
<li>분석 회의체: 대시보드를 통해 함께 문제를 탐색하고 개선할 목표 지표 함께 논의하는 단계</li>
<li>실험 및 선제적 분석: 데이터를 바탕으로 함께 조직의 문제를 해결할 수 있는 단계</li>
</ul>
</section>
<section id="실험-설계" class="level3">
<h3 class="anchored" data-anchor-id="실험-설계">(3) 실험 설계</h3>
<p>자, 데이터 및 데이터 조직에 대한 협업부서의 신뢰가 쌓였습니다. 이제 프라임 카드에 대한 가설을 세우고 협업부서와 함께 실험을 설계해봅시다. 이때 필요한 과정을 다음과 같이 간단히 정리했습니다.</p>
<ul>
<li>검증 가능한 가설 설정
<ul>
<li>목표 지표 정의: 협업 부서간 지표 합의가 필요하며 이 예시에서는 ’매출 증진’이 우선순위 지표primary index</li>
<li>가설 설정: “프라임 카드가 고객 구매금액을 늘리는 데 도움을 줄 수 있을 것이다.”</li>
</ul></li>
<li>실험 대상 및 기간 설정
<ul>
<li>실험에 필요한 표본 크기 계산: 2장에서 배운 검정력과 통계적으로 신뢰할 수 있는 최소 탐지 가능 효과minimum detectable effect(MDE)를 고려해 설정</li>
<li>실험 대상 정의: 이 예시에서는 10,000명의 고객을 대상으로 프라임 카드 제공 여부를 결정하기 위해 실험군과 대조군을 무작위로 배정</li>
<li>실험 기간 설정: 실험 기간을 적절히 설정해야만 인과효과를 정확히 추정할 수 있음. 실험 기간이 너무 짧아도 인과효과 추정에 어려움이 존재하며, 계절적 문제가 아닌 프라임 카드로 인한 효과를 파악하기 위한 기간 설정이 필요</li>
</ul></li>
<li>&nbsp;통제 가능한 요인 사전 파악</li>
</ul>
</section>
<section id="실험-진행-및-분석" class="level3">
<h3 class="anchored" data-anchor-id="실험-진행-및-분석">(4) 실험 진행 및 분석</h3>
<p>(1)부터 (4)까지의 과정을 거쳐, 이제 책&lt;실무로 통하는 인과추론 with 파이썬&gt;에서 배운 인과추론 방법론을 실무에 적용하는 실험을 시작할 수 있습니다. 이 단계에서는 실험 그룹을 기반으로 사전에 설계된 목표 지표를 검증하고 분석하는 작업을 진행합니다.</p>
<ul>
<li>실험 진행
<ul>
<li>지표 모니터링: 실험이 진행되는 동안, 고객 경험에 부정적인 요소(가드레일 지표guardrail index로 확인)가 있는지 및 실험에 영향을 주는 외부 요인이 있는지 모니터링</li>
<li>로그 확인: 실험 분석에 사용될 데이터가 잘 쌓이고 있는지 확인</li>
</ul></li>
<li>실험 분석
<ul>
<li>불응 문제: 프라임 카드 제공은 무작위로 배정되었지만, 고객이 스스로 프라임 카드를 선택할 수 있는 불응 문제가 존재하며 이에 따른 적절한 도구변수 선택이 필요</li>
<li>LATE 추정: 이 과정에서는 11.6절에서 배운 2단계 최소제곱법(2SLS)를 활용해 프라임 카드를 선택한 사람들의 효과를 추정</li>
<li>민감도 분석: 인과효과의 신뢰성 확보를 위해, 11.7절에서 배운 표준오차를 기반으로 신뢰구간을 계산. 추정값의 분산이 크다면 4.9절에 나온 CUPED 방법을 통해 잡음을 제거할 수 있음</li>
</ul></li>
<li>실험 결과 리포트 및 대시보드 제공</li>
</ul>
</section>
<section id="실험을-바탕으로-의사결정-및-피드백" class="level3">
<h3 class="anchored" data-anchor-id="실험을-바탕으로-의사결정-및-피드백">(5) 실험을 바탕으로 의사결정 및 피드백</h3>
<p>실험 분석을 마치고 나면, 인과효과에 대해 다음과 같은 비판적 질문을 던질 수 있어야 합니다. 예를 들어 실험이 원활하게 진행되지 않았다면 앞에서 살펴본 ①부터 ④까지의 과정에서 어떤 점이 부족했는지 파악하고 보완하는 것이 중요합니다.</p>
<ul>
<li>도구변수 식별 가정: 도구변수에 대한 4가지 가정이 잘 지켜졌는가?</li>
<li>순응률: 순응률이 낮아서 예상보다 더 많은 표본이 필요했던 것은 아닌가?</li>
</ul>
<p>또한, 프라임 카드의 개선 가능성에 대해 다음과 같은 질문을 고려해볼 수 있습니다.</p>
<ul>
<li>개인화: 프라임 카드가 특히 효과적이었던 고객 그룹은 어떤 그룹인가?</li>
<li>신기 효과: 프라임 카드 도입 후, 얼마까지 효과가 지속되는가?</li>
</ul>
<p>성공적인 A/B 테스트 결과가 나온다면, 은행은 프라임 카드 도입을 통한 매출 증대를 기대할 수 있습니다. 그러나 실제 제품에 반영하는 것은 A/B 테스트 결과뿐만 아니라 고객 경험과 서비스 상황(프라임 카드 유지 비용, 서비스 유지 리소스 등)을 고려하여 신중하게 결정되어야 합니다.</p>
</section>
</section>
<section id="reference" class="level2">
<h2 class="anchored" data-anchor-id="reference">Reference</h2>
<p>“실무로 통하는 인과추론 with 파이썬”을 읽으실 때, 잠시 쉬어가며 맨 뒷장의 에필로그를 읽어보시는 것을 추천드리며, 자세한 내용은 <a href="https://product.kyobobook.co.kr/detail/S000212577153">번역서의 에필로그</a> 및 <a href="https://www.hanbit.co.kr/channel/category/category_view.html?cms_code=CMS8017671681">한빛미디어 공식 블로그</a>를 참고해주세요. 그리고 댓글을 통해 저의 에필로그에 대한 여러분의 생각을 들려주세요!</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/CausalInferenceLab\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="CausalInferenceLab/CausalInferenceLab.github.io" issue-term="pathname" theme="dark-blue" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->




</body></html>