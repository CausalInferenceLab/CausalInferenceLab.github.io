<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="seongsoo kim &amp; hojae jeong">
<meta name="dcterms.date" content="2023-11-05">
<meta name="description" content="Introduction to Causal Inference 강의 chapter 4 소개">

<title>PseudoLab Causal Inference Team - Chapter 4. Causal Models</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
<meta property="og:title" content="PseudoLab Causal Inference Team">
<meta property="og:description" content="현업 데이터 분석가가 인과추론을 공부하고 현업에 적용하면서 느낀 생각을 정리한 자료입니다.">
<meta property="og:image" content="https://github.com/CausalInferenceLab/Causal-Inference-Study-for-Analyst/posts/Chapter_4/images/pseudo_lab_eng.png">
<meta property="og:site-name" content="PseudoLab Causal Inference Team">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../images/causal_inference_team_logo.jpg" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">PseudoLab Causal Inference Team</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">about</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/CausalInferenceLab/Causal-Inference-Study-for-Analyst" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Chapter 4. Causal Models</h1>
                  <div>
        <div class="description">
          <p>Introduction to Causal Inference 강의 chapter 4 소개</p>
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">chapter4</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>seongsoo kim &amp; hojae jeong </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 5, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#contents" id="toc-contents" class="nav-link active" data-scroll-target="#contents">Contents</a></li>
  <li><a href="#do-operator란-무엇인가요" id="toc-do-operator란-무엇인가요" class="nav-link" data-scroll-target="#do-operator란-무엇인가요">(1) Do-operator란 무엇인가요?</a></li>
  <li><a href="#modularity-assumption" id="toc-modularity-assumption" class="nav-link" data-scroll-target="#modularity-assumption">(2) Modularity Assumption</a></li>
  <li><a href="#backdoor-adjustment" id="toc-backdoor-adjustment" class="nav-link" data-scroll-target="#backdoor-adjustment">(3) Backdoor adjustment</a></li>
  <li><a href="#structural-causal-models-구조적-인과-모델" id="toc-structural-causal-models-구조적-인과-모델" class="nav-link" data-scroll-target="#structural-causal-models-구조적-인과-모델">(4)Structural causal models (구조적 인과 모델)</a></li>
  <li><a href="#reference" id="toc-reference" class="nav-link" data-scroll-target="#reference">Reference&nbsp;</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<section id="contents" class="level3">
<h3 class="anchored" data-anchor-id="contents">Contents</h3>
<ul>
<li>Do-operator and Interventional Distributions</li>
<li>Modularity Assumption</li>
<li>Backdoor adjustment</li>
<li>Structural causal models</li>
</ul>
<p>◦&nbsp;강의 영상 링크 :&nbsp;<a href="https://www.youtube.com/watch?v=AuZu0L0PEgk">Chapter 4 - Causal Models</a></p>
<p>&nbsp; &nbsp; 작성된 내용 중 개선점이나 잘못된 부분이 있다면 댓글로 알려주세요!</p>
<p>◦ 이번 강의는 아래의 내용을 다룰 예정입니다.</p>
<p>&nbsp; &nbsp; &nbsp;Casual Inference를 할 때, 이론적으로 대답할 수 없는 <strong>Causal Estimand</strong>를 여러가지 가정을 통해 계산할 수 있는<br>
&nbsp; &nbsp; &nbsp;<strong>Statistical Estimand</strong>로 추정하게 됩니다. 이때 필요한 개념인 <strong>Causal Model</strong>에 대해서 학습합니다.</p>
<p><img src="ex_image1.png" class="img-fluid"></p>
<hr>
</section>
<section id="do-operator란-무엇인가요" class="level3">
<h3 class="anchored" data-anchor-id="do-operator란-무엇인가요">(1) Do-operator란 무엇인가요?</h3>
<ul>
<li>정의 : 주어진 현상을 그대로 관찰하는게 아닌, 더 나아가 “<strong>개입한다</strong>”라는 것을 표현하는 수학 연산자입니다.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(Intervention)</li>
<li>역할 : Do-operator를 통해, <strong>Treament에 영향을 줄 수 있는 모든 요인의 효과를 무시</strong>할 수 있게 됩니다.&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(Treatment의 부모 노드)</li>
<li>Conditioning (조건) vs Intervention (개입)&nbsp;</li>
</ul>
<blockquote class="blockquote">
<p>◦ <strong>Conditioning on</strong> <span class="math inline">\(T=t\)</span> : 전체 모집단 or 관측한 데이터에서 Treatment <span class="math inline">\(t\)</span>를 받은 모집단의 부분 집합에 해당합니다.<br>
◦ <strong>Intervention on</strong> <span class="math inline">\(T=t\)</span> : 처치한 부분 집합이 아닌, 전체 모집단에 대해서 <span class="math inline">\(T=t\)</span> 로 설정한 것을 말합니다.<br>
&nbsp; &nbsp; &nbsp;- 통상적으로 Intervention은 <span class="math inline">\(do(T=t), do(t)\)</span>로 표현합니다.<br>
&nbsp; &nbsp; &nbsp;- 이는 주어진 현상을 그대로 관찰하는 것이 아닌, Doing(개입)한다라는 의미로 이해할 수 있습니다.</p>
<p>◦ 아래와 같이 Conditioning과 Intervention은 서로 다른 표현방식이므로, 다른 데이터 분포를 형성합니다.<br>
</p>
<p><img src="ex_image2.png" class="img-fluid"></p>
</blockquote>
<ul>
<li>Observational Distribution&nbsp;vs Interventional Distribution</li>
</ul>
<blockquote class="blockquote">
<p><strong>◦ Observational distribution</strong>&nbsp;<br>
&nbsp; &nbsp; &nbsp;- 표현 : <span class="math inline">\(P(Y),P(Y,T,X)\)</span>&nbsp; &nbsp; &nbsp;- 특징 : 개입(doing)이 없이,&nbsp;생성된 분포를 Observational distribution이라 합니다.</p>
<p><strong>◦ Interventional&nbsp;distribution</strong>&nbsp;<br>
&nbsp; &nbsp; &nbsp;-&nbsp;표현 : <span class="math inline">\(P(Y|do(T=t)),P(Y|do(T=t),X=x))\)</span><br>
&nbsp; &nbsp; &nbsp;- 특징 : Treatment에 대한 <strong>개입 (do-operator)이 존재</strong>합니다.&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; → &nbsp;처치(<span class="math inline">\(T\)</span>)를 통해 Randomized trial실험과 같은 효과를 낼 수 있으며, 이러한 데이터를 통해 추정된 인과 효과를<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <strong>Causal Estimand</strong>라고 합니다.<br>
&nbsp; &nbsp; &nbsp; &nbsp; →&nbsp;반면, do-operator를 포함하지 않은 추정치 (Estimand)는 <strong>Statistical Estimand</strong>라고 합니다.&nbsp; &nbsp; &nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;- 예시 : <span class="math inline">\(P(Y|do(T=t),Z = z)\)</span>가 의미하는 것은 무엇일까요?<br>
&nbsp; &nbsp; &nbsp; &nbsp; → 모집단에 대해서 <span class="math inline">\(T=t\)</span>에 대한 개입을 받은 Z=z인 부분집합에 해당하는 데이터라고 할 수 있습니다.</p>
<p><img src="ex_image3.png" class="img-fluid"></p>
<ul>
<li><strong>Identifiability</strong> :</li>
</ul>
<p>◦ 정의 : 개입을 통해 얻은 Causal Estimand를 <strong>Identification 가정</strong>을 통해 Statistical Estimand로 바꾸는 과정<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(직접 계산할 수 없음, Counterfactuals)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(직접 계산가능) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br>
&nbsp; &nbsp; → 이 때, Confounders <span class="math inline">\(X\)</span>를 제어하는데 필요한 Causal Models의 요소를 이번 Chapter에서 배울 예정입니다!</p>
<p><img src="ex_image4.png" class="img-fluid"></p>
</blockquote>
<p><strong>(참고) Do-operator</strong></p>
<p>여기서 Do-operator는 쉽게 말해서 “개입한다”라는 의미입니다. 다시말해서 Do-operator의 역할은, Treament에 영향을 줄 수 있는 모든 변수의 효과를 무시하게 만들어줍니다.</p>
<p><img src="ex_image5.png" class="img-fluid"></p>
<p>여기서 <span class="math inline">\(P(Y|X)\)</span>는 인과효과가 아니에요. 왜냐하면 Confounder로 인한, Backdoor path가 열려 있기 때문이죠.</p>
<p>Do-operator를 적용하면, X에 영향을 주는 C→ X 사이의 연결고리를 그래프 상에서 <strong>이론적</strong>으로 없애는 것이며,이 상태에서 계산한 <span class="math inline">\(P(Y|do(X))\)</span> 값이 바로 인과 효과라는 것입니다.</p>
<p><img src="ex_image6.png" class="img-fluid"></p>
<p>이러한 Do-operator는 실제 계산할 수 있는 값이라기 보다는 이론적인 개념이며, 그래서 결국 Do-operator를 수학적으로 계산할 수 있는 조건부 확률로&nbsp;만들어줘야 하는데, 이때 필요한 가정을 앞에서 배운 <strong>Identification</strong> 입니다.</p>
<p>“정리하자면, Interventional probability를 통해 Casual effect를 정의하고, Identifiable인지를 통해서 실제로 추정 가능한지에 대해 판단하며, 이를 통해 인과 관계를 구해보자는 것이죠”</p>
</section>
<section id="modularity-assumption" class="level3">
<h3 class="anchored" data-anchor-id="modularity-assumption">(2) Modularity Assumption</h3>
<ul>
<li>앞으로 Identification을 하기 위해서 가정이 필요한데요, 해당 가정에 대해 배워보도록 할게요!</li>
<li>Causal Indentification를 하기 위한 중요한 가정 : Interventions are local</li>
<li>그러면, Interventions are local이 무엇일까요?</li>
</ul>
<blockquote class="blockquote">
<p>◦&nbsp;&nbsp;의미 : 어떤 노드에 개입(Intervention)하게 되면, <strong>개입으로 인한 변화가 local</strong>하다는 것입니다.<br>
◦&nbsp;&nbsp;효과 : 즉, 개입한 노드 <span class="math inline">\(X_i\)</span>에 대해서 부모 노드 <span class="math inline">\(pa_i\)</span>가 미치는 영향만 변하고, 나머지 노드에서 주는 영향은 유지가 된다라는 것입니다.<br>
◦&nbsp; 예시 : 아래 그림에서, 해당 가정에 따르면 원 안에 있는 <span class="math inline">\(X_i\)</span>의 부모 노드(<span class="math inline">\(pa_i\)</span>)가 미치는 영향만 변화하고,<br>
&nbsp; &nbsp; &nbsp;나머지는 영향은 유지 됩니다.</p>
<p><img src="ex_image7.png" class="img-fluid"></p>
</blockquote>
<ul>
<li><strong>Modularity assumption</strong> : Interventions are local을 일반화한 가정</li>
</ul>
<blockquote class="blockquote">
<p>◦ 정의 :&nbsp;</p>
<hr>
<p>&nbsp; &nbsp;어떤 Graph 상 n개의 노드가 존재하고, 그 중 개입(intervention)을 한 노드의 인덱스 집합을 S라고 한다면,<br>
&nbsp; &nbsp; 1. 노드 i가 개입되지 않은 경우 (<span class="math inline">\(i∉S\)</span>) 노드 i (<span class="math inline">\(X_i\)</span>)의 부모 노드(<span class="math inline">\(pa_i\)</span>)가 노드 <span class="math inline">\(i\)</span>에 미치는 영향은 그대로 유지<br>
&nbsp; &nbsp; 2. 노드 i가 개입되었다면 (<span class="math inline">\(i∈S\)</span>), <span class="math inline">\(x_i\)</span>값으로 개입한 경우 <span class="math inline">\(P(x_i|pa_i)\)</span> = 1,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="math inline">\(x_i\)</span>값으로 개입하지 않은 경우 <span class="math inline">\(P(x_i|pa_i)\)</span> = 0</p>
<p>&nbsp; &nbsp; &nbsp;* [n] = 1,2,3,4…,n 이며 각 숫자는 노드의 index를 의미<br>
&nbsp; &nbsp; &nbsp; &nbsp; <span class="math inline">\(X_i\)</span>: Index가 i인 노드를 의미, <span class="math inline">\(x_i\)</span> : 값(scalar)을 의미</p>
<hr>
<p>◦ Assumption violation : 그러면, Modularity 가정이 위배된다는 것은 어떤 의미일까요?</p>
<p>&nbsp; &nbsp; &nbsp;- 노드 <span class="math inline">\(T\)</span> 에 대한 개입(intervention)이 <span class="math inline">\(T\)</span>의 부모 노드에 대한 영향력에 변화를 줄 뿐만 아니라, &nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp;<span class="math inline">\(T_2\)</span>의 부모 노드에 대해&nbsp;변화를 주었을 때, “Intervention이 local이 아니다”라고 합니다.</p>
<p><img src="ex_image8.png" class="img-fluid"></p>
<p>◦ 예시&nbsp;:&nbsp;<br>
&nbsp; &nbsp; (a) 개입이 없는 Observational distribution<br>
&nbsp; &nbsp;&nbsp;(b) <span class="math inline">\(T\)</span>에 개입 : <span class="math inline">\(T\)</span>의 부모 노드에서 오는 영향만 사라지고, 나머지는 유지됩니다.<br>
&nbsp; &nbsp;&nbsp;(c) <span class="math inline">\(T_2\)</span>에 개입 : <span class="math inline">\(T_2\)</span>의 부모 노드에서 오는 영향이 사라지고, 나머지는 유지됩니다.<br>
&nbsp; &nbsp; &nbsp;→ <span class="math inline">\(P(Y)\)</span>, <span class="math inline">\(P(Y|do(T=t))\)</span>, <span class="math inline">\(P(Y|do(T_2=t_2))\)</span>는 서로 연관되지 않은 완전히 다른 분포가 됩니다.<br>
&nbsp; &nbsp; &nbsp;→ (b), (c) 처럼 edge가 제거된 그래프를 <strong>Manipulated graph</strong>라고 해요!</p>
<p><br>
<img src="ex_image9.png" class="img-fluid"></p>
</blockquote>
<ul>
<li>Truncated factorization</li>
</ul>
<blockquote class="blockquote">
<p>◦ 우리는 방금 배운 Modularity assumption을 통해 새로운 식을 추론해낼 수 있어요.&nbsp;<br>
◦ 정의 : Bayesian network factorization에서 <strong>modularity assumption</strong>이 적용된 식입니다.&nbsp;</p>
<p>◦ 과정 : 그럼 지난 시간에 배운 내용을 Remind 해볼까요?<br>
&nbsp; &nbsp; 1. Bayesian network factoriazation<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;= Chain rule of probability + Markov assumption</p>
<p><img src="ex_image10.png" class="img-fluid"></p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; - Chain rule of probability : <span class="math inline">\(P(x,y) = P(x)⋅P(y|x)\)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp; - Markov assumption : 모든 노드는 오직 부모 노드로부터 영향을 받습니다.</p>
<p>&nbsp; &nbsp; 2. Modularity assumption 적용<br>
&nbsp; &nbsp; &nbsp; &nbsp;여기서 개입(intervention)을 한 노드의 인덱스 집합을 S라고 한다면, <span class="math inline">\(i∈S\)</span> 인 노드들에 대해서는,<br>
&nbsp; &nbsp; &nbsp; &nbsp;<span class="math inline">\(P(x_i|pa_i)\)</span> = 1이기 때문에, bayesian network factorization 계산 과정에서 생략이 가능합니다.</p>
<p>&nbsp; &nbsp; &nbsp; → &nbsp;따라서 <span class="math inline">\(i∉S\)</span>인 노드들에 대해서만 <span class="math inline">\(P(x_i|pa_i)\)</span>를 계산하면 되며, bayesian network factorization<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;식에서 아래와 같은 식을 도출할 수 있습니다.</p>
<p>&nbsp;<br>
<img src="ex_image11.png" class="img-fluid"></p>
<p>◦ 예시 : <span class="math inline">\(P(y|do(t))\)</span>를 Identify 해봅시다.</p>
<p>→ Treatment <span class="math inline">\(T\)</span>에 영향을 미치는 부분이, 제거 (Trucated) 됩니다.</p>
<p><img src="ex_image12.png" class="img-fluid"></p>
</blockquote>
</section>
<section id="backdoor-adjustment" class="level3">
<h3 class="anchored" data-anchor-id="backdoor-adjustment">(3) Backdoor adjustment</h3>
<ul>
<li>이전 내용에서 개입(Doing)을 통해서 Treatment에 영향을 주는 외부 변수(Backdoor)를 차단하면서<br>
Casual effect를 구할 수 있다고 했습니다.</li>
</ul>
<blockquote class="blockquote">
<ol type="1">
<li>Q : 그러면, Observational data에서 어떻게 Causal effect를 구할 수 있을까요?<br>
&nbsp; &nbsp; &nbsp;A : 관측 데이터인 observational data에서는 개입(intervention)을 통해 그래프를 마음대로 변경하기는 어려워요.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;하지만 아래 그림과 같이 Observational data의 Graph에 조건을 추가한다면, <span class="math inline">\(P(Y|do(X))\)</span>와 <strong>동일한 효과</strong>를<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;줄 수 있지 않을까요?</li>
</ol>
<p>&nbsp; &nbsp; * 아래 그래프에서의 Backdoor Paths (Non-causal association)<br>
&nbsp; &nbsp; &nbsp; &nbsp;◦&nbsp;<span class="math inline">\(T - W - Y\)</span><br>
&nbsp; &nbsp; &nbsp; &nbsp;◦ <span class="math inline">\(T - C - Y\)</span></p>
<p><img src="ex_image13.png" class="img-fluid"></p>
<ol start="2" type="1">
<li>Q : 그렇다면 어떠한 조건을 통해, Observation data에서 Doing(개입)한 것과 동일한 효과를 낼 수 있을까요?<br>
&nbsp; &nbsp; &nbsp;A : Observation data Graph에 추가할 조건에 대한 기준이 필요합니다. 해당 조건을 정리한 것이 바로,<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<strong>Backdoor criterion</strong>입니다.</li>
</ol>
</blockquote>
<ul>
<li>Backdoor Criterion :</li>
</ul>
<blockquote class="blockquote">
<p>◦ 정의 : <span class="math inline">\(T → Y\)</span>간의 Causal association을 제외한 모든 Backdoor paths를 막을 수 있는 변수들의 집합 <span class="math inline">\(W\)</span><br>
◦ 조건 :<br>
&nbsp; &nbsp;1. 집합 W는 T에서 Y로 가는 모든 Backdoor paths를 block<br>
&nbsp; &nbsp;2. 집합 W는 T의 어느 자손도 포함하지 말아야 함</p>
<p>◦ Sufficient adjustment set : Modularity 가정이 주어졌을 때, 변수들의 집합 <span class="math inline">\(W\)</span>가 Backddor Criterion을<br>
&nbsp; &nbsp; 만족한다면, <span class="math inline">\(W\)</span>를 Sufficient adjustment set이라고 합니다.</p>
<p>◦ 의미 : <span class="math inline">\(W\)</span>가 Backdoor Criterion을 만족하게 되면, <span class="math inline">\(T\)</span>에 대한 <span class="math inline">\(Y\)</span>의 <strong>Causal Effect</strong>를 <strong>Identify 할 수 있어요!</strong></p>
<p>◦ 예시&nbsp;:&nbsp;&nbsp; &nbsp;</p>
<p>1. &nbsp;만약 confounder가 있다면, <strong>confounder를 통제를 해야</strong> backdoor path를 막을 수 있습니다. 이러한 confounder의 집합이 backdoor criterion을 만족하는 집합이라고 볼 수 있겠죠.&nbsp;</p>
<p>2.&nbsp;<strong>반면에 collider는 통제하면 안됩니다.</strong> 따라서 이러한 collider는 backdoor criterion을 만족하는 집합이라고 볼 수 없습니다.</p>
<p>&nbsp; &nbsp; &nbsp;→&nbsp;즉, 우리가 해야하는 것은 backdoor criterion을 만족하는 모든 집합을 통제해야해요!</p>
<p>◦ 증명 : 그렇다면 정말 Backdoor adjustment를 통해 Doing(개입)의 효과를 얻을 수 있을까요?<br>
&nbsp; &nbsp; 1. &nbsp;<span class="math inline">\(P(Y|do(t),W)=P(Y|T,W)\)</span>&nbsp; &lt; line 1 to line 2 &gt;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - Backdoor criterion 1번 조건에 의해 <span class="math inline">\(W\)</span>는 모든 backdoor paths를 차단합니다.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; → 따라서, <span class="math inline">\(T\)</span>로 들어오는 edge의 영향이 제거 됩니다!</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - 좌변 : <span class="math inline">\(do(t)\)</span>의 modularity assumption에 의해 <span class="math inline">\(T\)</span>에 들어오는 edge의 영향이 제거<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -&nbsp;우변 : <span class="math inline">\(W\)</span>를 condition함으로써, <span class="math inline">\(T\)</span>로 들어오는 edge의 영향을 제거</p>
<p>&nbsp; &nbsp; 2.&nbsp;&nbsp;<span class="math inline">\(P(W|do(t)) = P(W)\)</span> &lt; line 2 to line 3 &gt;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; - <span class="math inline">\(T=t\)</span> 라고 통제를 했으므로, <span class="math inline">\(W\)</span>→<span class="math inline">\(T\)</span> 관계가 사라집니다. (독립)<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; →&nbsp; 따라서, Backdoor adjustment를 통해 observational data를 가지고 앞에서 Casual로 정의한&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="math inline">\(P(Y|do(t))\)</span>를 규명할 수 있습니다.</p>
<p><img src="ex_image14.png" class="img-fluid"></p>
</blockquote>
<ul>
<li>Backdoor Criterion과 D-separation : D-separation을 backdoor criterion 가지고 정의해봅시다.</li>
</ul>
<blockquote class="blockquote">
<p>1. Backdoor criterion &lt; 왼쪽 그림 &gt;<br>
&nbsp; &nbsp; &nbsp;-&nbsp;조건 1. 집합 <span class="math inline">\(W\)</span>는 <span class="math inline">\(T\)</span>에서 <span class="math inline">\(Y\)</span>로 가는 모든 backdoor paths를 막아야합니다.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;열려 있는 Backdoor path는 <span class="math inline">\(W_2\)</span> or <span class="math inline">\(W_1\)</span>→ Blocked<br>
&nbsp; &nbsp; &nbsp;-&nbsp;조건 2. 집합 <span class="math inline">\(W\)</span>는 <span class="math inline">\(T\)</span>의 어느 자손도 포함하지 말아야 합니다.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span class="math inline">\(T\)</span>의 자손인 <span class="math inline">\(X_2\)</span>가 막혀 있습니다. → Unblocked</p>
<p>2. &nbsp;Backdoor adjustment 처리 된 그래프 <span class="math inline">\(G\)</span> &lt; 가운데 그림 &gt;<br>
&nbsp; &nbsp; &nbsp;-&nbsp;그리고 단 하나의 Association도 존재하지 않는 조건부 독립을 의미하는 D-separated는 <span class="math inline">\(T\)</span>→<span class="math inline">\(M_1\)</span>으로 가는<br>
&nbsp; &nbsp; &nbsp; &nbsp;edge를 제거하게 됩니다.</p>
<p>3. D-separation &lt; 오른쪽 그림 &gt;<br>
&nbsp; &nbsp; &nbsp;-&nbsp;이렇게 하여 생성된 그래프를 아래 그림과 같이 <span class="math inline">\(G_{\bar{T}}\)</span>로 표현하고, <span class="math inline">\(W\)</span> 컨디션 아래에서 <span class="math inline">\(Y\)</span>와 <span class="math inline">\(T\)</span>는<br>
&nbsp; &nbsp; &nbsp; &nbsp;d-separated 되었다고 표현합니다.</p>
<p><img src="ex_image15.png" class="img-fluid"></p>
</blockquote>
</section>
<section id="structural-causal-models-구조적-인과-모델" class="level3">
<h3 class="anchored" data-anchor-id="structural-causal-models-구조적-인과-모델">(4)Structural causal models (구조적 인과 모델)</h3>
<ul>
<li>구조적 인과모델 (Structural Casual Model)은 변수들 사이의 인과 관계를 구조화 된 함수로 나타내는 것입니다.</li>
<li>표현 : 수학에서 쓰는 ‘=’ 과는 달리, causation 상에서는 역이 성립하지 않으며, 아래와 같이 표기합니다.<br>
◦&nbsp; Structural equation&nbsp;B := f(A)<br>
◦ 여기서 A와 B 의 mapping이 deterministic 합니다. 명확한 관계가 이외의 <strong>확률적인 부분 (Stochastic)</strong>을<br>
&nbsp; &nbsp; 고려하기 위해선 B의 unknown causes도 인지해야 해요. 그래서 해당 변수를 고려하면 아래와 같습니다.<br>
&nbsp; &nbsp; →&nbsp;&nbsp;B := f(A,U)</li>
</ul>
<p><img src="ex_image16.png" class="img-fluid"></p>
<ul>
<li>Structural Casual Models</li>
</ul>
<blockquote class="blockquote">
<p>◦&nbsp;정의 : Structural causal models은 다음 3개의 집합에 대한 튜플(Tuple)입니다.</p>
<p>&nbsp; &nbsp; 1.&nbsp;&nbsp;U : 외생(exogenous) 변수, 모델 밖에서 그 값이 결정되는 변수들의 집합<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;- 부모 노드가 없는 변수로 이 노드의 causes를 모델링 할 필요가 없습니다.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;- 아래 그림에서는 변수 <span class="math inline">\(U_B, U_C, U_D\)</span>에 해당합니다.<br>
&nbsp; &nbsp; 2.&nbsp;&nbsp;V : 내생(endogenous) 변수, 모델 내에서 다른 변수들에 의해 설명되는 집합<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;- 부모노드가 존재하는 변수로 모델링 하고자하는 structural equation의 변수<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;- 아래 그림에서는 변수&nbsp; <span class="math inline">\(B, C, D\)</span>에 해당합니다.</p>
<p>&nbsp; &nbsp; 3.&nbsp;&nbsp;f : 모델 내 다른 변수들에 따라 V에 속한 변수들의 값을 결정하는 함수 집합</p>
<p><img src="ex_image17.png" class="img-fluid"></p>
<p>◦&nbsp;Structural Causal Model (SCM)를 쓰는 이유가 무엇일까요?</p>
<p>&nbsp; &nbsp; 1. Potential Outcomes 표현<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;- SCM에서 <span class="math inline">\(T=t\)</span>로 고정했을때 나오는 결과 값은 potential outcome 입니다.</p>
<p>&nbsp; &nbsp;&nbsp;2. 일반화된 분포 고려 가능<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;- DAG로 표현 시, Causal direction이 다를 수 있어 인과관계를 확인하기에 적합하지 않아요.<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;하지만 SCM은 DAG의 구조적 할당을 따르며 SEM (Strctural Equation Models)의 functional form을<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;통해, intervention set을 지정할 수 있습니다. 따라서, 더 많은 상황에서의 분포를 고려할 수 있어요.</p>
<p>&nbsp; &nbsp;&nbsp;3. Causal Models 체계화&nbsp;<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;- 그래프 기반으로 인과관계를 분석하는 건 간단하지만 이런 그래프가 복잡해지면 직관적인 이해만으론 한계가<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;존재합니다. 그렇기 때문에, 그래프 기반의 인과관계 분석을 수학적인 언어를 통해 보다 체계화 할 수 있어요.</p>
<p>◦&nbsp;예시 : 아래 그래프를 SCM 구조로 표현해봅시다.</p>
<ul>
<li><p><span class="math inline">\(U=\)</span> {<span class="math inline">\(X\)</span>}, <span class="math inline">\(V=\)</span> {<span class="math inline">\(T,Y\)</span>}, <span class="math inline">\(F=\)</span> {<span class="math inline">\(f_T,f_Y\)</span>}</p></li>
<li><p><span class="math inline">\(f_T:=\alpha_1X\)</span></p></li>
<li><p><span class="math inline">\(f_Y:=\beta T+\alpha_2X\)</span></p>
<p><br>
<img src="ex_image18.png" class="img-fluid"></p></li>
</ul>
</blockquote>
<ul>
<li>&nbsp;SCMs에서의 Intervention : Modularity assumption에 의해 SCM(M)과 Interventional SCM(<span class="math inline">\(M_t\)</span>)에는 <span class="math inline">\(M_t\)</span>에서 개입이 일어나는 변수 <span class="math inline">\(T\)</span>에 대한 구조방정식이 T:=t로 대체되는 것 외, 개입이 일어나지 않는 다른 변수에 대한 구조 방정식은 동일합니다.</li>
</ul>
<p><img src="ex_image19.png" class="img-fluid"></p>
<ul>
<li>The Law of Counterfactuals (and Interventions)</li>
</ul>
<blockquote class="blockquote">
<p>◦ 정의 : &nbsp;<span class="math inline">\(Y_t(u) = Y_{M_t}(u)\)</span><br>
◦ 의미 : SCM에 대한 충분한 정보가 있는 경우, 실질적으로 Counterfactuals을 계산 할 수 있다는 Principle입니다.<br>
◦ 의의 : Chapter 2에서 이야기한 인과추론의 근본적인 문제이기 때문입니다.&nbsp;<br>
&nbsp; &nbsp; 해당 내용은 Chapter 14에서 더 세부적으로 다룰 예정이에요.</p>
</blockquote>
<ul>
<li>Collider과 Treatment의 자식노드는 왜 Condition을 하지 않을까요?</li>
</ul>
<blockquote class="blockquote">
<ol type="1">
<li>Causation을 막기 때문입니다.<br>
&nbsp; &nbsp; ◦ 왼쪽 그림 : 아래 그림은 <span class="math inline">\(T\)</span>와 <span class="math inline">\(Y\)</span>가 d-seperarted되어, 모든 causation이 막힌 상황입니다.<br>
&nbsp; &nbsp; ◦&nbsp;오른쪽 그림 : Causation이 있기 위해서는 <span class="math inline">\(T\)</span>와 <span class="math inline">\(Y\)</span> 사이에 direct path가 있으면 됩니다.<br>
&nbsp; &nbsp; &nbsp; &nbsp; → 이러한 blocking causal association 이유로 descendants of treatment를 condition 하지 않습니다.</li>
</ol>
<p><img src="ex_image20.png" class="img-fluid"></p>
<ol start="2" type="1">
<li><p>새로운 형태의 Association이 생기기 때문입니다 : new post-treatment association<br>
&nbsp; &nbsp; ◦오른쪽 그림 : <span class="math inline">\(M\)</span>에서 관측되지 않은 외생변수 <span class="math inline">\(U_M\)</span>과 <span class="math inline">\(T\)</span>, <span class="math inline">\(M\)</span>사이엔 collider가 있다고 볼 수 있어요.<br>
&nbsp; &nbsp; &nbsp; &nbsp;→&nbsp;collider의 자식 노드인 <span class="math inline">\(Z\)</span>를 condition하면, 새로운 post-treatment association이 발생할 수 있습니다!<br>
&nbsp;<br>
<img src="ex_image21.png" class="img-fluid"></p></li>
<li><p>새로운 형태의 Association이 생기기 때문입니다 : new pre-treatment association &lt; M-bias &gt;<br>
&nbsp; &nbsp; ◦ 아래 그림에서도 <span class="math inline">\(Z2\)</span> 가 collider이므로, M-bias 형태에서 conditioning 시킬 수 없습니다.<br>
</p>
<p><img src="ex_image22.png" class="img-fluid"></p></li>
</ol>
</blockquote>
<hr>
<section id="backdoor-adjustment-예제" class="level4">
<h4 class="anchored" data-anchor-id="backdoor-adjustment-예제">Backdoor Adjustment 예제</h4>
<blockquote class="blockquote">
<p><strong>◦ 데이터 설명</strong><br>
&nbsp; &nbsp;- 상황 : 미국인의 46%가 고혈압이 있고 고혈압은 사망률 증가와 연관되어 있습니다.<br>
&nbsp; &nbsp;- 가설 : 이때 나트륨 섭취가 고혈압에 영향을 줄까요?<br>
&nbsp; &nbsp;- Outcome : 혈압<br>
&nbsp; &nbsp;- Treatment : 나트륨 섭취<br>
&nbsp; &nbsp;- Covariates <span class="math inline">\(W\)</span> : 나이,&nbsp; Covariates <span class="math inline">\(Z\)</span> : 소변에 배출되는 단백질 양<br>
&nbsp; &nbsp; &nbsp;→ 나이는 혈압과 신체의 나트륨 수치를 조절하는 Confounder이며, 소변에 배출되는 단백질 양이 많은 것은<br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 고혈압과 나트륨 섭취량이 많기 때문입니다. 즉, <span class="math inline">\(Z\)</span>는 Colider이며 <span class="math inline">\(W\)</span>는 Cofounder 입니다.</p>
<p><img src="ex_image23.png" class="img-fluid"></p>
<p><strong>◦ Causal Graph</strong><br>
&nbsp; &nbsp;-&nbsp;위에서 배운 Backdoor criterion에 의하면, Confounder인 <span class="math inline">\(W\)</span>에 대한 Backdoor path만 막으면 됩니다.&nbsp;<br>
&nbsp; &nbsp; &nbsp;Identification을 통해, 계산할 수 있는 Statistical estimand를 그래프 이용해 도출해 봅시다.</p>
<p>&nbsp; &nbsp;-&nbsp;Chapter 3에서 배운 방식으로 Statistical estimand를 작성해보면, <span class="math inline">\(E_w,zE[Y|t,W]\)</span> 이지만,colider인 <span class="math inline">\(z\)</span>는<br>
&nbsp; &nbsp; &nbsp;막을 필요가 없어요. 그래서 Causal graph를 통해 도출된 Statistical estimand는 <span class="math inline">\(E_wE[Y|t,W]\)</span>입니다.<br>
</p>
<p><img src="ex_image24.png" class="img-fluid"></p>
<p><strong>◦ Identification</strong>&nbsp;<br>
&nbsp; &nbsp;-&nbsp;위와 같은 방식을 통해, Backdoor path를 어떤 변수를 가지고 조절해야 하는지 쉽게 알 수 있습니다.</p>
<p>&nbsp; &nbsp;-&nbsp;우리가 구해야하는 값(Causal estimand) : <span class="math inline">\(E[Y|do(t)]\)</span><br>
&nbsp; &nbsp;-&nbsp;우리가 구할 수 있는 값(Statistical estimand from causal graph) : <span class="math inline">\(E_wE[Y|t,W]\)</span></p>
<p>&nbsp; &nbsp;-&nbsp;우리가 배운 과정을 적용해보면 최초의 종속변수는 ‘sodium’, ‘age’, ’proteinuria’과 같았겠죠?<br>
&nbsp; &nbsp; &nbsp; 이 때, Collider인 proteinuria (단백뇨)를 제거해서 ’sodium’과 ’age’를 종속변수로 활용해봅시다.</p>
<p><img src="ex_image25.png" class="img-fluid"></p>
<p><strong>◦ Estimation</strong>&nbsp; &nbsp;-&nbsp;데이터를 통해 ATE estimation을 확인하면, 각 Condition 마다 차이는 아래와 같습니다.<br>
&nbsp; &nbsp;- 1) 변수 통제 하지 않았을 때 오류 : 407%<br>
&nbsp; &nbsp; &nbsp;2) <span class="math inline">\(T\)</span>,<span class="math inline">\(Y\)</span> 변수와 관계된 모든 영향을 통제했을 때 오류 : 19%<br>
&nbsp; &nbsp; &nbsp;3) Backdoor path를 차단했을 때 오류 : 0.02%</p>
<p><img src="ex_image26.png" class="img-fluid"></p>
</blockquote>
<ul>
<li>위 과정을 Python code를 활용해, 간단한 실험을 진행해볼게요.</li>
</ul>
<p><img src="ex_image27.png" class="img-fluid"></p>
<p>이전 예제에서의 변수간 영향력을 알 수 없으므로 위 그림과 같이 변수간의 관계를 숫자로 표현하였습니다.</p>
<pre><code>import numpy as np
import pandas as pd
import statsmodels.formula.api as sm

np.random.seed(12345)
num = 10000

W = np.random.normal(size = num)

T = 6 * W + np.random.normal(size = num)
Y = 5 * T +  3 * W + np.random.normal(size = num)
Z = 2 * T + 7 * Y + np.random.normal(size = num)

data = pd.DataFrame({'T':T,'Y':Y,'Z':Z,'W':W})</code></pre>
<p>우리가 구하고자 하는 관계는 T가 Y에 미치는 인과관계를 구하고 이때 그림과 같이 5로 설정했습니다.</p>
<p>먼저 어떠한 종속변수를 통제하지 않고 선형회귀모델을 사용하여 관계를 구해볼게요.</p>
<pre><code>model1 = sm.ols('Y ~ T', data).fit()
model1.summary().tables[1]</code></pre>
<p><img src="ex_image28.png" class="img-fluid"></p>
<p>Y에 대한 T의 영향이 5.4866으로 0.4866이라는 잡음이 생겼네요. 교란변수를 통제하지 않아서 오차가 생겼습니다.</p>
<p>그러면 Y와 T사이 영향을 주는 모든 변수를 통제해볼까요?</p>
<pre><code>model2 = sm.ols('Y ~ T + W +Z', data).fit()
model2.summary().tables[1]</code></pre>
<p><img src="ex_image29.png" class="img-fluid"></p>
<p>Y에 대한 T의 영향이 -0.1770으로 우리가 구하고자 하는 5란 값과 매우 멀어졌습니다.</p>
<p>collider를 통제하면서 Y와 T간의 새로운 종속 관계를 만들어 내어 collider bias를 만들었군요.</p>
<p>이처럼 모든 변수를 통제하여 collider 또한 통제하게 되면&nbsp;편향이 발생할 위험이 있습니다.</p>
<p>마지막으로 Y와 T사이 collider인 Z는 제거하지 말고 교란변수인 W만 통제해보겠습니다.</p>
<pre><code>model3 = sm.ols('Y ~ T + W', data).fit()
model3.summary().tables[1]</code></pre>
<p><img src="ex_image30.png" class="img-fluid"></p>
<p>Y에 대한 T의 영향이 4.9967으로 가장 5에 가까운 결과를 도출해냈습니다.</p>
<p>변수간의 관계를 파악하여 non-causal association은 통제하고 정확한 causal association을 찾아내는 과정은 중요합니다.&nbsp;&nbsp;</p>
<p><strong>To be continued)</strong> 다음은 인과관계를 학습하는데 있어, Gold standard라고 불리는 Randomized Experiment에 대해 배울 예정입니다.</p>
</section>
</section>
<section id="reference" class="level3">
<h3 class="anchored" data-anchor-id="reference">Reference&nbsp;</h3>
<blockquote class="blockquote">
<p>◦ Lecture Notes : 2021 Summer Session on Causal Inference (박지용 교수님)&nbsp;<a href="https://sites.google.com/view/causal-inference2021/lecture-materials?authuser=0">[Link]</a><br>
◦ Blog<br>
&nbsp; &nbsp;- Backdoor Adjustment <a href="https://everyday-tech.tistory.com/entry/backdoor-adjustment?category=995410">[Link]</a><br>
&nbsp; &nbsp;-&nbsp;인과추론. 그래프와 확률&nbsp;<a href="https://pizzathief.oopy.io/causal-graph-for-beginners">[Link]</a></p>
</blockquote>


</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@online{kim &amp; hojae jeong2023,
  author = {kim \&amp; hojae jeong, seongsoo},
  title = {Chapter 4. {Causal} {Models}},
  date = {2023-11-05},
  url = {https://github.com/CausalInferenceLab/Causal-Inference-Study-for-Analyst/posts/Chapter_4/4.Causal_Models.html},
  langid = {en}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-kim &amp; hojae jeong2023" class="csl-entry quarto-appendix-citeas" role="listitem">
&amp; hojae jeong, seongsoo kim. 2023. <span>“Chapter 4. Causal
Models.”</span> November 5, 2023. <a href="https://github.com/CausalInferenceLab/Causal-Inference-Study-for-Analyst/posts/Chapter_4/4.Causal_Models.html">https://github.com/CausalInferenceLab/Causal-Inference-Study-for-Analyst/posts/Chapter_4/4.Causal_Models.html</a>.
</div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>